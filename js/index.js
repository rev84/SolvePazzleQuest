// Generated by CoffeeScript 1.10.0
var PuzzleQuest, Utl;

PuzzleQuest = (function() {
  function PuzzleQuest() {}

  PuzzleQuest.CONST_X = 8;

  PuzzleQuest.CONST_Y = 8;

  PuzzleQuest.CONST_CELL_EMPTY = null;

  PuzzleQuest.CONST_CELL_GREEN = 10;

  PuzzleQuest.CONST_CELL_RED = 20;

  PuzzleQuest.CONST_CELL_YELLOW = 30;

  PuzzleQuest.CONST_CELL_BLUE = 40;

  PuzzleQuest.CONST_CELL_GOLD = 100;

  PuzzleQuest.CONST_CELL_EXP = 110;

  PuzzleQuest.CONST_CELL_SKULL = 120;

  PuzzleQuest.CONST_CELL_SKULL5 = 130;

  PuzzleQuest.initialized = false;

  PuzzleQuest.eCells = [];

  PuzzleQuest.cells = [];

  PuzzleQuest.init = function() {
    var j, k, ref, ref1, results, td, tr, x, y;
    if (this.initialized) {
      return;
    }
    this.initialized = true;
    this.eCells = Utl.array2dFill(this.CONST_X, this.CONST_Y);
    this.cells = Utl.array2dFill(this.CONST_X, this.CONST_Y, this.CONST_CELL_EMPTY);
    results = [];
    for (y = j = 0, ref = this.CONST_Y; 0 <= ref ? j < ref : j > ref; y = 0 <= ref ? ++j : --j) {
      tr = $('<tr>');
      for (x = k = 0, ref1 = this.CONST_X; 0 <= ref1 ? k < ref1 : k > ref1; x = 0 <= ref1 ? ++k : --k) {
        td = $('<td>').addClass('cell').appendTo(tr);
        this.eCells[x][y] = td;
      }
      results.push($('#board tbody').append(tr));
    }
    return results;
  };

  PuzzleQuest.getScores = function(cells) {
    var copy, j, k, ref, ref1, ref2, ref3, score, scores, x, y;
    if (cells == null) {
      cells = this.cells;
    }
    scores = [];
    for (x = j = 0, ref = cells.length; 0 <= ref ? j < ref : j > ref; x = 0 <= ref ? ++j : --j) {
      for (y = k = 0, ref1 = cells[x].length; 0 <= ref1 ? k < ref1 : k > ref1; y = 0 <= ref1 ? ++k : --k) {
        score = 0;
        if (x + 1 < cells.length) {
          copy = Utl.clone(cells);
          ref2 = [copy[x + 1][y], copy[x][y]], copy[x][y] = ref2[0], copy[x + 1][y] = ref2[1];
          score += this.getScore(copy);
        }
        scores.push({
          x: x,
          y: y,
          direction: "x",
          score: score
        });
        score = 0;
        if (y + 1 < cells[x].length) {
          copy = Utl.clone(cells);
          ref3 = [copy[x][y + 1], copy[x][y]], copy[x][y] = ref3[0], copy[x][y + 1] = ref3[1];
          score += this.getScore(copy);
        }
        scores.push({
          x: x,
          y: y,
          direction: "y",
          score: score
        });
      }
    }
    scores.sort(function(a, b) {
      if (a.score < b.score) {
        return 1;
      }
      if (a.score > b.score) {
        return -1;
      }
      return 0;
    });
    return scores;
  };

  PuzzleQuest.getScore = function(inputCells) {
    var cells, chain, chains, e, emptyCells, firstScore, j, k, l, len, len1, len2, n, o, p, q, randScore, ref, ref1, score, tempChain, tempX, tempY, x, y;
    cells = Utl.clone(inputCells);
    chains = this.getChain(cells);
    score = 0;
    if (chains.length !== 0) {
      firstScore = 0;
      for (j = 0, len = chains.length; j < len; j++) {
        chain = chains[j];
        if (chain.length === 3) {
          firstScore += 1;
        } else if (chain.length >= 4) {
          firstScore += 100;
        }
        for (k = 0, len1 = chain.length; k < len1; k++) {
          tempChain = chain[k];
          tempX = tempChain[0], tempY = tempChain[1];
          cells[tempX][tempY] = this.CONST_CELL_EMPTY;
        }
      }
      cells = this.fall(cells);
      emptyCells = [];
      for (x = l = 0, ref = cells.length; 0 <= ref ? l < ref : l > ref; x = 0 <= ref ? ++l : --l) {
        for (y = o = 0, ref1 = cells[x].length; 0 <= ref1 ? o < ref1 : o > ref1; y = 0 <= ref1 ? ++o : --o) {
          if (cells[x][y] === this.CONST_CELL_EMPTY) {
            emptyCells.push([x, y]);
          }
        }
      }
      randScore = 0;
      for (n = p = 0; p < 1000; n = ++p) {
        for (q = 0, len2 = emptyCells.length; q < len2; q++) {
          e = emptyCells[q];
          cells[e[0]][e[1]] = (function() {
            var c;
            c = [this.CONST_CELL_GREEN, this.CONST_CELL_RED, this.CONST_CELL_YELLOW, this.CONST_CELL_BLUE, this.CONST_CELL_GOLD, this.CONST_CELL_EXP, this.CONST_CELL_SKULL];
            return c[Utl.rand(0, c.length - 1)];
          })();
        }
        randScore += this.getScore(cells);
      }
      randScore /= 1000;
      score += firstScore + randScore;
    }
    return score;
  };

  PuzzleQuest.randomize = function() {
    var cells, flag, j, k, ref, ref1, x, y;
    this.init();
    cells = [this.CONST_CELL_GREEN, this.CONST_CELL_RED, this.CONST_CELL_YELLOW, this.CONST_CELL_BLUE, this.CONST_CELL_GOLD, this.CONST_CELL_EXP, this.CONST_CELL_SKULL];
    flag = true;
    while (flag) {
      for (x = j = 0, ref = this.CONST_X; 0 <= ref ? j < ref : j > ref; x = 0 <= ref ? ++j : --j) {
        for (y = k = 0, ref1 = this.CONST_Y; 0 <= ref1 ? k < ref1 : k > ref1; y = 0 <= ref1 ? ++k : --k) {
          this.cells[x][y] = cells[Utl.rand(0, cells.length - 1)];
        }
      }
      flag = this.getChain().length !== 0;
    }
    return this.redraw();
  };

  PuzzleQuest.getChain = function(inputCells) {
    var cells, chains, j, k, l, me, o, ref, ref1, ref2, ref3, ref4, ref5, tempChain, x, xPlus, y, yPlus;
    if (inputCells == null) {
      inputCells = this.cells;
    }
    cells = Utl.clone(inputCells);
    chains = [];
    for (x = j = 0, ref = cells.length; 0 <= ref ? j < ref : j > ref; x = 0 <= ref ? ++j : --j) {
      for (y = k = 0, ref1 = cells[x].length; 0 <= ref1 ? k < ref1 : k > ref1; y = 0 <= ref1 ? ++k : --k) {
        me = cells[x][y];
        if (!(0 < x && this.isChainable(me, cells[x - 1][y]))) {
          tempChain = [[x, y]];
          for (xPlus = l = ref2 = x + 1, ref3 = cells.length; ref2 <= ref3 ? l < ref3 : l > ref3; xPlus = ref2 <= ref3 ? ++l : --l) {
            if (!this.isChainable(me, cells[xPlus][y])) {
              break;
            }
            tempChain.push([xPlus, y]);
          }
          if (tempChain.length >= 3) {
            chains.push(tempChain);
          }
        }
        if (!(0 < y && this.isChainable(me, cells[x][y - 1]))) {
          tempChain = [[x, y]];
          for (yPlus = o = ref4 = y + 1, ref5 = cells[x].length; ref4 <= ref5 ? o < ref5 : o > ref5; yPlus = ref4 <= ref5 ? ++o : --o) {
            if (!this.isChainable(me, cells[x][yPlus])) {
              break;
            }
            tempChain.push([x, yPlus]);
          }
          if (tempChain.length >= 3) {
            chains.push(tempChain);
          }
        }
      }
    }
    return chains;
  };

  PuzzleQuest.fall = function(inputCells) {
    var cells, i, j, k, l, ref, ref1, ref2, temp, x, y;
    if (inputCells == null) {
      inputCells = this.cells;
    }
    cells = Utl.clone(inputCells);
    for (x = j = 0, ref = cells.length; 0 <= ref ? j < ref : j > ref; x = 0 <= ref ? ++j : --j) {
      temp = [];
      for (y = k = 0, ref1 = cells[x].length; 0 <= ref1 ? k < ref1 : k > ref1; y = 0 <= ref1 ? ++k : --k) {
        if (cells[x][y] !== this.CONST_CELL_EMPTY) {
          temp.push(cells[x][y]);
        }
      }
      for (i = l = 0, ref2 = cells[x].length - temp.length; 0 <= ref2 ? l < ref2 : l > ref2; i = 0 <= ref2 ? ++l : --l) {
        temp.unshift(this.CONST_CELL_EMPTY);
      }
      cells[x] = temp;
    }
    return cells;
  };

  PuzzleQuest.isChainable = function(me, target) {
    var chainable;
    chainable = (function() {
      switch (me) {
        case this.CONST_CELL_RED:
          return [this.CONST_CELL_RED];
        case this.CONST_CELL_GREEN:
          return [this.CONST_CELL_GREEN];
        case this.CONST_CELL_YELLOW:
          return [this.CONST_CELL_YELLOW];
        case this.CONST_CELL_BLUE:
          return [this.CONST_CELL_BLUE];
        case this.CONST_CELL_GOLD:
          return [this.CONST_CELL_GOLD];
        case this.CONST_CELL_EXP:
          return [this.CONST_CELL_EXP];
        case this.CONST_CELL_SKULL:
          return [this.CONST_CELL_SKULL, this.CONST_CELL_SKULL5];
        default:
          return [];
      }
    }).call(this);
    return Utl.inArray(target, chainable);
  };

  PuzzleQuest.redraw = function() {
    var img, j, ref, results, x, y;
    results = [];
    for (x = j = 0, ref = this.CONST_X; 0 <= ref ? j < ref : j > ref; x = 0 <= ref ? ++j : --j) {
      results.push((function() {
        var k, ref1, results1;
        results1 = [];
        for (y = k = 0, ref1 = this.CONST_Y; 0 <= ref1 ? k < ref1 : k > ref1; y = 0 <= ref1 ? ++k : --k) {
          img = (function() {
            switch (this.cells[x][y]) {
              case this.CONST_CELL_RED:
                return 'red';
              case this.CONST_CELL_GREEN:
                return 'green';
              case this.CONST_CELL_YELLOW:
                return 'yellow';
              case this.CONST_CELL_BLUE:
                return 'blue';
              case this.CONST_CELL_GOLD:
                return 'gold';
              case this.CONST_CELL_EXP:
                return 'exp';
              case this.CONST_CELL_SKULL:
                return 'skull';
            }
          }).call(this);
          results1.push(this.eCells[x][y].css('background-image', 'url(./img/' + img + '.png)'));
        }
        return results1;
      }).call(this));
    }
    return results;
  };

  return PuzzleQuest;

})();

$(function() {
  return PuzzleQuest.init();
});

Utl = (function() {
  function Utl() {}

  Utl.numFormat = function(num) {
    return String(num).replace(/(\d)(?=(\d\d\d)+(?!\d))/g, '$1,');
  };

  Utl.rand = function(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  };

  Utl.adrBar = function(url) {
    return window.history.replaceState('', '', '' + url);
  };

  Utl.normalize = function(num, min, max) {
    var range;
    if (min == null) {
      min = 0;
    }
    if (max == null) {
      max = 1;
    }
    range = Math.abs(max - min);
    if (num < min) {
      num += range * Math.ceil(Math.abs(num - min) / range);
    } else if (max <= num) {
      num -= range * (Math.floor(Math.abs(num - max) / range) + 1);
    }
    return num;
  };

  Utl.time = function(date) {
    if (date == null) {
      date = null;
    }
    if (date === null) {
      date = new Date();
    }
    return Math.floor(+date / 1000);
  };

  Utl.militime = function(date, getAsFloat) {
    if (date == null) {
      date = null;
    }
    if (getAsFloat == null) {
      getAsFloat = false;
    }
    if (date === null) {
      date = new Date();
    }
    return +date / (getAsFloat ? 1000 : 1);
  };

  Utl.dateStr = function(date, dateSep) {
    if (date == null) {
      date = null;
    }
    if (dateSep == null) {
      dateSep = '-';
    }
    if (date === null) {
      date = new Date();
    }
    return '' + this.zerofill(date.getFullYear(), 4) + dateSep + this.zerofill(date.getMonth() + 1, 2) + dateSep + this.zerofill(date.getDate(), 2);
  };

  Utl.datetimeStr = function(date, dateSep, timeSep, betweenSep) {
    if (date == null) {
      date = null;
    }
    if (dateSep == null) {
      dateSep = '-';
    }
    if (timeSep == null) {
      timeSep = ':';
    }
    if (betweenSep == null) {
      betweenSep = ' ';
    }
    if (date === null) {
      date = new Date();
    }
    return this.dateStr(date, dateSep) + betweenSep + this.zerofill(date.getHours(), 2) + timeSep + this.zerofill(date.getMinutes(), 2) + timeSep + this.zerofill(date.getSeconds(), 2);
  };

  Utl.difftime = function(targetDate, baseDate, nowSec, nowStr, agoStr, secStr, minStr, hourStr, dayStr, monStr, yearStr) {
    var baseTime, d, diffTime, h, m, mo, targetTime, y;
    if (baseDate == null) {
      baseDate = null;
    }
    if (nowSec == null) {
      nowSec = 0;
    }
    if (nowStr == null) {
      nowStr = 'ついさっき';
    }
    if (agoStr == null) {
      agoStr = '前';
    }
    if (secStr == null) {
      secStr = '秒';
    }
    if (minStr == null) {
      minStr = '分';
    }
    if (hourStr == null) {
      hourStr = '時間';
    }
    if (dayStr == null) {
      dayStr = '日';
    }
    if (monStr == null) {
      monStr = '月';
    }
    if (yearStr == null) {
      yearStr = '年';
    }
    if (baseDate === null) {
      baseTime = this.time();
    }
    targetTime = this.time(targetDate);
    diffTime = baseTime - targetTime;
    if (diffTime < 0) {
      return null;
    }
    if (nowSec >= diffTime) {
      return nowStr;
    }
    y = Math.floor(diffTime / (60 * 60 * 24 * 30 * 12));
    if (y > 0) {
      return '' + y + yearStr + agoStr;
    }
    diffTime -= y * (60 * 60 * 24 * 30 * 12);
    mo = Math.floor(diffTime / (60 * 60 * 24 * 30));
    if (mo > 0) {
      return '' + mo + monStr + agoStr;
    }
    diffTime -= mo * (60 * 60 * 24 * 30);
    d = Math.floor(diffTime / (60 * 60 * 24));
    if (d > 0) {
      return '' + d + dayStr + agoStr;
    }
    diffTime -= d * (60 * 60 * 24);
    h = Math.floor(diffTime / (60 * 60));
    if (h > 0) {
      return '' + h + hourStr + agoStr;
    }
    diffTime -= h * (60 * 60);
    m = Math.floor(diffTime / 60);
    if (m > 0) {
      return '' + m + minStr + agoStr;
    }
    diffTime -= m * 60;
    if (diffTime > 0) {
      return '' + diffTime + secStr + agoStr;
    }
    return nowStr;
  };

  Utl.zerofill = function(num, digit) {
    return ('' + this.repeat('0', digit) + num).slice(-digit);
  };

  Utl.repeat = function(str, times) {
    return Array(1 + times).join(str);
  };

  Utl.shuffle = function(ary) {
    var i, n, ref;
    n = ary.length;
    while (n) {
      n--;
      i = this.rand(0, n);
      ref = [ary[n], ary[i]], ary[i] = ref[0], ary[n] = ref[1];
    }
    return ary;
  };

  Utl.inArray = function(needle, ary) {
    var j, len, v;
    for (j = 0, len = ary.length; j < len; j++) {
      v = ary[j];
      if (v === needle) {
        return true;
      }
    }
    return false;
  };

  Utl.clone = function(obj) {
    if ($.isArray(obj)) {
      return $.extend(true, [], obj);
    } else if (obj instanceof Object) {
      return $.extend(true, {}, obj);
    }
    return obj;
  };

  Utl.arrayFill = function(length, val) {
    var i, j, ref, res;
    if (val == null) {
      val = null;
    }
    res = [];
    for (i = j = 0, ref = length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      res[i] = val;
    }
    return res;
  };

  Utl.array2dFill = function(x, y, val) {
    var j, k, ref, ref1, res, xx, yAry, yy;
    if (y == null) {
      y = null;
    }
    if (val == null) {
      val = null;
    }
    if (y === null) {
      y = x;
    }
    res = [];
    yAry = [];
    for (yy = j = 0, ref = y; 0 <= ref ? j < ref : j > ref; yy = 0 <= ref ? ++j : --j) {
      yAry[yy] = val;
    }
    for (xx = k = 0, ref1 = x; 0 <= ref1 ? k < ref1 : k > ref1; xx = 0 <= ref1 ? ++k : --k) {
      res[xx] = this.clone(yAry);
    }
    return res;
  };

  Utl.count = function(object) {
    return Object.keys(object).length;
  };

  Utl.uuid4 = function() {
    var i, j, random, uuid;
    uuid = '';
    for (i = j = 0; j < 32; i = ++j) {
      random = Math.random() * 16 | 0;
      if (i === 8 || i === 12 || i === 16 || i === 20) {
        uuid += '-';
      }
      uuid += (i === 12 ? 4 : (i === 16 ? random & 3 | 8 : random)).toString(16);
    }
    return uuid;
  };

  return Utl;

})();
